# Специфікація вимог на проект "Whishly"

## Титульна сторінка
**Проект:** Whishly  
**Лабораторна робота №1:** Аналіз вимог та створення документації  
**Група:** 18  
**Розробники:**
- ІО-36 Варшавський Тимур
- ІО-36 Карлик Максим

---

## 1. Вступ
**Мета проекту:**  
Мобільний додаток, який допомагає користувачам створювати власні списки бажань, категоризувати їх та ділитися ними з іншими людьми.

**Опис проблеми:**  
У багатьох користувачів виникає потреба організувати свої бажання та ідеї у зручному вигляді. Замість зберігання посилань у нотатках або закладках, додаток надає зрозумілий інтерфейс для створення структурованих списків бажань.

**Основні цілі:**
- Створення мобільного додатку з базовими CRUD-операціями для списків бажань.
- Організація вішлістів за категоріями.
- Можливість ділитися списками через публічні посилання.

---

## 2. Опис системи
**Ролі користувачів:**
- **Користувач** – реєстрація, створення списків, додавання елементів, редагування, видалення, категоризація, поширення.
- **Гість (viewer)** – доступ за публічним посиланням до перегляду списку без редагування.

**Основні функції:**
- Реєстрація та авторизація користувача.
- Створення, редагування та видалення списків бажань.
- Додавання елементів із можливістю прикріплення посилань, описів, фото.
- Категоризація списків.
- Поширення списків за посиланням.

---

## 3. Функціональні та нефункціональні вимоги (таблиця)

| №  | Вимога                                                                 | Тип              | Пріоритет |
|----|------------------------------------------------------------------------|------------------|-----------|
| 1  | Користувач може зареєструватися та увійти у систему                    | Функціональна    | Високий   |
| 2  | Користувач може створювати, редагувати та видаляти списки бажань       | Функціональна    | Високий   |
| 3  | Користувач може додавати елементи (назва, опис, посилання, фото)       | Функціональна    | Високий   |
| 4  | Користувач може створювати категорії для вішлістів                     | Функціональна    | Високий   |
| 5  | Користувач може ділитися списком через унікальне посилання             | Функціональна    | Високий   |
| 6  | Гість може переглядати список, але не змінювати його                   | Функціональна    | Високий   |
| 7  | Інтерфейс додатку простий та інтуїтивний                               | Нефункціональна  | Високий   |
| 8  | Екрани додатку завантажуються ≤ 2 секунд                               | Нефункціональна  | Високий   |
| 9  | Дані зберігаються у захищеній базі даних                               | Нефункціональна  | Високий   |
| 10 | Підтримка офлайн-режиму з синхронізацією                               | Функціональна    | Середній  |
| 11 | Пуш-сповіщення при оновленні чи шерінгу списку                         | Функціональна    | Низький   |


---

## 4. Нефункціональні вимоги
- **Зручність:** простий та зрозумілий інтерфейс користувача.
- **Зрозумілість:** інтуїтивна навігація, логічна структура додатку.
- **Швидкодія:** екран додатку має завантажуватися не більше ніж за 2 секунди.

---

## 5. Пріоритетність вимог
- **Високий пріоритет:** авторизація, CRUD для списків та елементів, категорії, поширення списків.
- **Середній пріоритет:** додавання фото, офлайн-режим з подальшою синхронізацією.
- **Низький пріоритет:** пуш-сповіщення, розширені ролі доступу.

---

## 6. Стек технологій
**Frontend (мобільний додаток):**
- React Native (Expo)
- TypeScript
- React Navigation (навігація між екранами)
- Zustand (глобальний стан)
- TanStack Query (робота з API, кешування)

**Backend:**
- NestJS (REST API)
- TypeScript
- JWT (авторизація)
- Redis (кеш та сесії)

**Database:**
- PostgreSQL (реляційна база даних)
- Prisma (ORM, міграції)

**Інфраструктура:**
- Git + GitHub (контроль версій)
- Railway / Render (хостинг бекенду та бази даних)

---

## 7. Ролі членів команди
- **ІО-36 Варшавський Тимур** – аналіз вимог, бекенд-модуль «категорії», фронтенд-екран «категорії», тестування API.
- **ІО-36 Карлик Максим** – проектування структури БД, бекенд-модуль «списки», фронтенд-екран «списки», інтеграція CRUD.
- **Спільно:** код-рев’ю, обговорення вимог, документація.

---
## Documentation

- [Lab 2 — Architecture design](Lab2.md)
- [Lab 3 — UI Prototype](Lab3.md)
- [Lab 4 — Базова структура коду та організація репозиторію](#лабораторна-робота-4--базова-структура-коду-та-організація-репозиторію)

---

## Лабораторна робота 4 — Базова структура коду та організація репозиторію

### Мета роботи
- Засвоїти принципи побудови базової структури програмного проєкту відповідно до обраної архітектури.
- Визначити основні класи, модулі та функції і розподілити завдання між членами команди.
- Створити базову структуру коду та завантажити її до репозиторію на GitHub.

### Принципи SOLID (коротко)
- **S — Single Responsibility**: кожен клас/модуль має одну відповідальність.
- **O — Open/Closed**: розширення через нові реалізації, без модифікації існуючих.
- **L — Liskov Substitution**: підкласи взаємозамінні з базовим типом.
- **I — Interface Segregation**: дрібні спеціалізовані інтерфейси замість «важких» універсальних.
- **D — Dependency Inversion**: залежність від абстракцій (контрактів), а не від конкретних реалізацій.

### Структура репозиторію (мінімум)
```
/src          # вихідний код
/tests        # тести (заглушки/скелети на цьому етапі)
/docs         # документація (діаграми, опис)
README.md     # опис проєкту, структура, ролі, інструкції
.gitignore    # виключення для Git
```

### Приклад структури коду (React Native, feature-first)
```
src/
  app/
    navigation/           # RootNavigator, AuthStack, AppTabs, linking config
    components/           # спільні UI-компоненти
    theme/                # тема (кольори, spacing, типографіка)
  core/
    api/                  # http‑клієнт, інтерсептори
    store/                # глобальний стан (наприклад, Zustand)
    types/                # доменні типи, схеми
    utils/                # хелпери
  features/
    auth/
      screens/
      services/
      repository/
    lists/
      screens/
      services/
      repository/
    items/
      screens/
      services/
      repository/
    categories/
      screens/
      services/
      repository/
    shared/
      screens/
      services/
      repository/
```

### Git‑процес (командна робота)
- Окрема гілка під кожне завдання: `feature/<назва‑модуля>`.
- Зміни потрапляють у `main` через Pull Request і код‑ревʼю.
- Основна гілка захищена: вимога PR та схвалення перед злиттям.


### Хід виконання роботи
1. Переглянути специфікацію та діаграми (див. `Lab2.md`, `Lab3.md`).
2. Визначити класи/модулі/функції та їх відповідальності (за SOLID).
3. Створити базові каталоги і скелети контрактів (інтерфейси/типи) без реалізації.
4. Ініціалізувати репозиторій, зробити перший коміт і пуш у GitHub.
5. Налаштувати робочий процес гілок та PR для команди.
6. Оновити `README.md`: структура, ролі, інструкції запуску (за потреби).

### Результат роботи
- Репозиторій на GitHub із базовою структурою коду (класи, модулі, функції — скелети).
- Документація у `README.md` (опис проєкту, структура, ролі, інструкції).
- Узгоджений Git‑процес (гілки, PR, код‑ревʼю).


---

## Встановлення та запуск

### Вимоги
- Node.js 18+
- npm або yarn
- Expo CLI (встановлюється автоматично)

### Встановлення залежностей

**Frontend:**
```bash
cd app/whishly
npm install
```

**Backend (мок):**
```bash
cd backend
npm install
```

### Запуск

**1. Запусти бекенд (json-server):**
```bash
cd backend
npx json-server --watch db.json --port 4000
```

**2. Запусти фронтенд (у новому терміналі):**
```bash
cd app/whishly
BASE_URL=http://localhost:4000 npx expo start
```

**3. Відкрий додаток:**
- Натисніть `i` для iOS симулятора
- Натисніть `a` для Android емулятора
- Або відскануй QR-код у Expo Go на телефоні

### Перевірка роботи API

Відкрий у браузері:
- `http://localhost:4000/lists` - список вішалістів
- `http://localhost:4000/items` - елементи списків

---

## Застосування SOLID у проекті

**S (Single Responsibility):**
- `authStore.ts` - тільки управління авторизацією (user, token, isAuthenticated)
- `apiClient.ts` - тільки HTTP-запити до бекенду
- `LoginScreen.tsx` - тільки UI логіна

**D (Dependency Inversion):**
- `ListRepository` інтерфейс – абстракція для роботи зі списками
- Компоненти залежать від інтерфейсу, а не від конкретної реалізації (API/Mock)

**Приклад:**
```typescript
// Погано (залежність від конкретної реалізації):
const lists = await apiClient.get('/lists');

// Добре (залежність від абстракції):
const listRepo: ListRepository = new ApiListRepository();
const lists = await listRepo.getLists();
```

**Переваги:**
- Легко замінити реалізацію (API → Mock для тестів)
- Легко тестувати (можна підставити Mock)
- Дотримання принципу Open/Closed (розширюваність без модифікації)