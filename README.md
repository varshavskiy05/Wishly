# Специфікація вимог на проект "Whishly"

## Титульна сторінка
**Проект:** Whishly  
**Лабораторна робота №1:** Аналіз вимог та створення документації  
**Група:** 18  
**Розробники:**
- ІО-36 Варшавський Тимур
- ІО-36 Карлик Максим

---

## 1. Вступ
**Мета проекту:**  
Мобільний додаток, який допомагає користувачам створювати власні списки бажань, категоризувати їх та ділитися ними з іншими людьми.

**Опис проблеми:**  
У багатьох користувачів виникає потреба організувати свої бажання та ідеї у зручному вигляді. Замість зберігання посилань у нотатках або закладках, додаток надає зрозумілий інтерфейс для створення структурованих списків бажань.

**Основні цілі:**
- Створення мобільного додатку з базовими CRUD-операціями для списків бажань.
- Організація вішлістів за категоріями.
- Можливість ділитися списками через публічні посилання.

---

## 2. Опис системи
**Ролі користувачів:**
- **Користувач** – реєстрація, створення списків, додавання елементів, редагування, видалення, категоризація, поширення.
- **Гість (viewer)** – доступ за публічним посиланням до перегляду списку без редагування.

**Основні функції:**
- Реєстрація та авторизація користувача.
- Створення, редагування та видалення списків бажань.
- Додавання елементів із можливістю прикріплення посилань, описів, фото.
- Категоризація списків.
- Поширення списків за посиланням.

---

## 3. Функціональні та нефункціональні вимоги (таблиця)

| №  | Вимога                                                                 | Тип              | Пріоритет |
|----|------------------------------------------------------------------------|------------------|-----------|
| 1  | Користувач може зареєструватися та увійти у систему                    | Функціональна    | Високий   |
| 2  | Користувач може створювати, редагувати та видаляти списки бажань       | Функціональна    | Високий   |
| 3  | Користувач може додавати елементи (назва, опис, посилання, фото)       | Функціональна    | Високий   |
| 4  | Користувач може створювати категорії для вішлістів                     | Функціональна    | Високий   |
| 5  | Користувач може ділитися списком через унікальне посилання             | Функціональна    | Високий   |
| 6  | Гість може переглядати список, але не змінювати його                   | Функціональна    | Високий   |
| 7  | Інтерфейс додатку простий та інтуїтивний                               | Нефункціональна  | Високий   |
| 8  | Екрани додатку завантажуються ≤ 2 секунд                               | Нефункціональна  | Високий   |
| 9  | Дані зберігаються у захищеній базі даних                               | Нефункціональна  | Високий   |
| 10 | Підтримка офлайн-режиму з синхронізацією                               | Функціональна    | Середній  |
| 11 | Пуш-сповіщення при оновленні чи шерінгу списку                         | Функціональна    | Низький   |


---

## 4. Нефункціональні вимоги
- **Зручність:** простий та зрозумілий інтерфейс користувача.
- **Зрозумілість:** інтуїтивна навігація, логічна структура додатку.
- **Швидкодія:** екран додатку має завантажуватися не більше ніж за 2 секунди.

---

## 5. Пріоритетність вимог
- **Високий пріоритет:** авторизація, CRUD для списків та елементів, категорії, поширення списків.
- **Середній пріоритет:** додавання фото, офлайн-режим з подальшою синхронізацією.
- **Низький пріоритет:** пуш-сповіщення, розширені ролі доступу.

---

## 6. Стек технологій
**Frontend (мобільний додаток):**
- React Native (Expo)
- TypeScript
- React Navigation (навігація між екранами)
- Zustand (глобальний стан)
- TanStack Query (робота з API, кешування)

**Backend:**
- NestJS (REST API)
- TypeScript
- JWT (авторизація)
- Redis (кеш та сесії)

**Database:**
- PostgreSQL (реляційна база даних)
- Prisma (ORM, міграції)

**Інфраструктура:**
- Git + GitHub (контроль версій)
- Railway / Render (хостинг бекенду та бази даних)

---

## 7. Ролі членів команди
- **ІО-36 Варшавський Тимур** – аналіз вимог, бекенд-модуль «категорії», фронтенд-екран «категорії», тестування API.
- **ІО-36 Карлик Максим** – проектування структури БД, бекенд-модуль «списки», фронтенд-екран «списки», інтеграція CRUD.
- **Спільно:** код-рев’ю, обговорення вимог, документація.

---
## Documentation

- [Lab 2 — Architecture design](Lab2.md)
- [Lab 3 — UI Prototype](Lab3.md)
- [Lab 4 — Базова структура коду та організація репозиторію](#лабораторна-робота-4--базова-структура-коду-та-організація-репозиторію)
- [Lab 5 — Інтеграція компонентів та управління залежностями](#лабораторна-робота-5--інтеграція-компонентів-та-управління-залежностями)

---

## Лабораторна робота 4 — Базова структура коду та організація репозиторію

### Мета роботи
- Засвоїти принципи побудови базової структури програмного проєкту відповідно до обраної архітектури.
- Визначити основні класи, модулі та функції і розподілити завдання між членами команди.
- Створити базову структуру коду та завантажити її до репозиторію на GitHub.

### Принципи SOLID (коротко)
- **S — Single Responsibility**: кожен клас/модуль має одну відповідальність.
- **O — Open/Closed**: розширення через нові реалізації, без модифікації існуючих.
- **L — Liskov Substitution**: підкласи взаємозамінні з базовим типом.
- **I — Interface Segregation**: дрібні спеціалізовані інтерфейси замість «важких» універсальних.
- **D — Dependency Inversion**: залежність від абстракцій (контрактів), а не від конкретних реалізацій.

### Структура репозиторію (мінімум)
```
/src          # вихідний код
/tests        # тести (заглушки/скелети на цьому етапі)
/docs         # документація (діаграми, опис)
README.md     # опис проєкту, структура, ролі, інструкції
.gitignore    # виключення для Git
```

### Приклад структури коду (React Native, feature-first)
```
src/
  app/
    navigation/           # RootNavigator, AuthStack, AppTabs, linking config
    components/           # спільні UI-компоненти
    theme/                # тема (кольори, spacing, типографіка)
  core/
    api/                  # http‑клієнт, інтерсептори
    store/                # глобальний стан (наприклад, Zustand)
    types/                # доменні типи, схеми
    utils/                # хелпери
  features/
    auth/
      screens/
      services/
      repository/
    lists/
      screens/
      services/
      repository/
    items/
      screens/
      services/
      repository/
    categories/
      screens/
      services/
      repository/
    shared/
      screens/
      services/
      repository/
```

### Git‑процес (командна робота)
- Окрема гілка під кожне завдання: `feature/<назва‑модуля>`.
- Зміни потрапляють у `main` через Pull Request і код‑ревʼю.
- Основна гілка захищена: вимога PR та схвалення перед злиттям.


### Хід виконання роботи
1. Переглянути специфікацію та діаграми (див. `Lab2.md`, `Lab3.md`).
2. Визначити класи/модулі/функції та їх відповідальності (за SOLID).
3. Створити базові каталоги і скелети контрактів (інтерфейси/типи) без реалізації.
4. Ініціалізувати репозиторій, зробити перший коміт і пуш у GitHub.
5. Налаштувати робочий процес гілок та PR для команди.
6. Оновити `README.md`: структура, ролі, інструкції запуску (за потреби).

### Результат роботи
- Репозиторій на GitHub із базовою структурою коду (класи, модулі, функції — скелети).
- Документація у `README.md` (опис проєкту, структура, ролі, інструкції).
- Узгоджений Git‑процес (гілки, PR, код‑ревʼю).


---

## Встановлення та запуск

### Вимоги
- Node.js 18+
- npm або yarn
- Expo CLI (встановлюється автоматично)

### Встановлення залежностей

**Frontend:**
```bash
cd app/whishly
npm install
```

**Backend (мок):**
```bash
cd backend
npm install
```

### Запуск

**1. Запусти бекенд (json-server):**
```bash
cd backend
npx json-server --watch db.json --port 4000
```

**2. Запусти фронтенд (у новому терміналі):**
```bash
cd app/whishly
BASE_URL=http://localhost:4000 npx expo start
```

**3. Відкрий додаток:**
- Натисніть `i` для iOS симулятора
- Натисніть `a` для Android емулятора
- Або відскануй QR-код у Expo Go на телефоні

### Перевірка роботи API

Відкрий у браузері:
- `http://localhost:4000/lists` - список вішалістів
- `http://localhost:4000/items` - елементи списків

---

## Застосування SOLID у проекті

**S (Single Responsibility):**
- `authStore.ts` - тільки управління авторизацією (user, token, isAuthenticated)
- `apiClient.ts` - тільки HTTP-запити до бекенду
- `LoginScreen.tsx` - тільки UI логіна

**D (Dependency Inversion):**
- `ListRepository` інтерфейс – абстракція для роботи зі списками
- Компоненти залежать від інтерфейсу, а не від конкретної реалізації (API/Mock)

**Приклад:**
```typescript
// Погано (залежність від конкретної реалізації):
const lists = await apiClient.get('/lists');

// Добре (залежність від абстракції):
const listRepo: ListRepository = new ApiListRepository();
const lists = await listRepo.getLists();
```

**Переваги:**
- Легко замінити реалізацію (API → Mock для тестів)
- Легко тестувати (можна підставити Mock)
- Дотримання принципу Open/Closed (розширюваність без модифікації)

---

## Лабораторна робота 5 — Інтеграція компонентів та управління залежностями

### Мета роботи
Завершити написання коду та провести інтеграцію всіх компонентів проекту, забезпечуючи їх сумісність та відповідність функціональним і нефункціональним вимогам.

### Метод інтеграції
**Локальна інтеграція:**
- Backend: json-server (мок API на локальному сервері)
- Frontend: React Native Expo (локальна розробка)
- Тестування: ручне тестування всіх сценаріїв

### Виконання функціональних вимог

| № | Вимога | Статус | Реалізація |
|---|--------|--------|------------|
| 1 | Реєстрація/логін | ✅ | `LoginScreen` - мок авторизація |
| 2 | CRUD списків | ✅ | `CreateListScreen`, `HomeScreen` - створення, перегляд, видалення |
| 3 | CRUD елементів | ✅ | `EditItemScreen`, `ListDetailsScreen` - створення, перегляд, видалення |
| 4 | Категорії | ✅ | `CategoriesScreen`, `CreateCategoryScreen` - створення, перегляд, видалення |
| 5 | Шаринг списків | ✅ | Генерація публічного посилання в `ListDetailsScreen` |
| 6 | Публічний перегляд | ✅ | `SharedListScreen` - read-only перегляд для гостей |

### Виконання нефункціональних вимог

| № | Вимога | Статус | Примітка |
|---|--------|--------|----------|
| 7 | Інтуїтивний інтерфейс | ✅ | Навігація через таби та модальні екрани |
| 8 | Швидкодія ≤ 2с | ✅ | React Query кешування, оптимізовані запити |
| 9 | Захист даних | ✅ | Токен зберігається (мок), публічні списки read-only |

### Структура інтегрованої системи

**Frontend модулі:**
- `features/auth/` - авторизація (LoginScreen)
- `features/lists/` - управління списками (HomeScreen, CreateListScreen)
- `features/items/` - управління елементами (ListDetailsScreen, EditItemScreen)
- `features/categories/` - управління категоріями (CategoriesScreen, CreateCategoryScreen)
- `features/shared/` - публічний перегляд (SharedListScreen)

**Backend (мок):**
- json-server на `http://localhost:4000`
- Endpoints: `/lists`, `/items`, `/categories`, `/shares`, `/users`

### Процес інтеграції

1. **Завершення реалізації компонентів:**
   - Створено всі екрани для CRUD операцій
   - Налаштована навігація між екранами
   - Інтегровано React Query для кешування

2. **Перевірка сумісності:**
   - Всі компоненти використовують спільний API-клієнт
   - Типи синхронізовані між frontend та backend
   - Навігація типізована для безпеки

3. **Тестування цілісності:**
   - Перевірено всі сценарії використання
   - Перевірено обробку помилок
   - Перевірено оновлення даних після мутацій

### Що було реалізовано

**1. Авторизація:**
- `LoginScreen` з мок-авторизацією через Zustand store
- Автоматичне перемикання навігації після логіну

**2. Управління списками:**
- `HomeScreen` - відображення всіх списків, видалення з підтвердженням через Alert
- `CreateListScreen` - створення нового списку з вибором категорії
- Інтеграція з React Query для автоматичного оновлення після мутацій

**3. Управління елементами:**
- `ListDetailsScreen` - перегляд елементів списку, видалення елементів, кнопка "Поділитися"
- `EditItemScreen` - створення нового елемента з полями: назва, опис, посилання
- Автоматичне оновлення списку після додавання елемента

**4. Управління категоріями:**
- `CategoriesScreen` - перегляд всіх категорій, видалення з підтвердженням
- `CreateCategoryScreen` - створення нової категорії
- Категорії доступні при створенні списку

**5. Функціональність шарингу:**
- Генерація публічного посилання через POST `/shares`
- Збереження `shareId` в списку через PATCH `/lists/:id`
- Копіювання посилання в буфер обмена через `expo-clipboard`
- Формат посилання: `whishly://shared/{shareId}`
- Якщо посилання вже існує - використовується існуюче, якщо ні - створюється нове

**6. Публічний перегляд:**
- `SharedListScreen` - read-only перегляд списку за `shareId`
- Доступний як для авторизованих, так і для неавторизованих користувачів
- Відображення списку та всіх елементів без можливості редагування

**7. Інтеграція компонентів:**
- Єдиний API-клієнт (`apiClient.ts`) з автоматичним додаванням Authorization header
- Zustand store для глобального стану авторизації
- React Query для кешування та автоматичної інвалідації після мутацій
- Типізована навігація для безпеки типів
- Умовний рендеринг навігації на основі стану авторизації

**8. Обробка помилок:**
- Валідація форм (обов'язкові поля)
- Підтвердження перед видаленням через Alert
- Відображення помилок завантаження користувачу
- Loading states під час запитів

### Результат інтеграції

✅ **Інтегрована система готова:**
- Всі компоненти коректно взаємодіють
- Реалізовані всі функціональні вимоги високого пріоритету
- Система відповідає нефункціональним вимогам
- Код типізований та без помилок лінтера
- Документація оновлена з інструкціями запуску